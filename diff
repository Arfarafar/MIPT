#include <stdio.h>
#include <diff.h>
#include <math.h>
#include <treegrap.h>
#include <assert.h>
#include <cstring>
//#include <cctype>
#include <cerrno>




void Print_tree_in_file(Node* cur_node, FILE* flout);
Node* Create_Node_from_file(FILE* flin, Node* Parent, int* length_remaining);
void Set_Type(char* fun, Node* cur_node);
void* Deconstruct_Nodes(Node* cur_node);
Node* Tree_Construct(FILE* flin);
Node* diff( Node* cur_node, char* variable);
Node* Optimize(Node **);





int main() {

    FILE* fltree = fopen("diff.txt", "r+");

    Node* head_node = Tree_Construct(fltree);
   // Treegraph(head_node);
   // head_node = Optimize(&head_node);
    //Treegraph(head_node);
    Node* After_diff = diff(head_node, "x");
   // Treegraph(After_diff);
    //After_diff = Optimize(&After_diff);
   // Treegraph(After_diff);
    //Deconstruct_Nodes(After_diff);
    Node* After_diff2 = diff(After_diff, "x");
   // Treegraph(After_diff2);
    fseek(fltree, 0, SEEK_SET);
    Print_tree_in_file(After_diff2, fltree);
    After_diff2 = Optimize(&After_diff2);
    Treegraph(After_diff2);
    //After_diff = diff(After_diff, "x");
    //Treegraph(After_diff);
    Deconstruct_Nodes(After_diff);
    Deconstruct_Nodes(After_diff2);
    Deconstruct_Nodes(head_node);
    fclose(fltree);
    return 0;
}

Node* Create_new_Node(Node* left, Node* right, int type, double num, int label){
    Node* newNode = (Node*)calloc(sizeof(Node), 1);
    newNode -> node_type = type;
    newNode -> left = left;
    newNode -> right = right;
    if (left){
        left -> parent = newNode;
    }
    if (right){
        right -> parent = newNode;
    }

    switch (type){
        case TYPE_NUM:
            newNode -> numdata = num;
            break;
        case TYPE_OPERATOR:
        case TYPE_VAR:
            newNode -> value = label;
            break;
        default:
            free(newNode);
            return nullptr;
    }

    return newNode;
}

Node* Execute (Node* side, Node* parent, Node** cur_node){

    if (parent) {
        if (&(*cur_node) == &side -> parent)
            printf("RAVH bl ");
        if (&(*cur_node) == &parent -> right || &(*cur_node) == &parent -> left )
            printf("RAVH bl ");

        (side -> parent -> left == side ? side -> parent -> left
                                        : side -> parent -> right) = nullptr;
        side-> parent -> parent = nullptr;

        Deconstruct_Nodes(side -> parent);
        parent -> left == side -> parent ? parent->left  = side
                                         : parent->right = side;
        side->parent = parent;
        *cur_node = nullptr;
        return parent;

    } else {
        Node* temp = side -> parent -> left == side ? (*cur_node) -> left
                                                    : (*cur_node) -> right;

        (side -> parent -> left == side ? side -> parent -> left
                                        : side -> parent -> right) = nullptr;
        temp -> parent = nullptr;
        Deconstruct_Nodes(*cur_node);
        *cur_node = temp;
    }
}

void Change_by_Number(Node** cur_node, double num){
    Deconstruct_Nodes((*cur_node) -> left);
    Deconstruct_Nodes((*cur_node) -> right);
    (*cur_node) -> node_type = TYPE_NUM;
    (*cur_node) -> numdata = num;
}

Node* Optimize(Node** cur_node){
    if(!cur_node)
        return nullptr ;
    if(!(*cur_node))
        return nullptr;
    Node* temp = nullptr;
    Node* parent = nullptr;
    Node* side = nullptr;
    switch ((*cur_node) -> node_type){
        case TYPE_NUM:
            return *cur_node;
        case TYPE_VAR:
            return *cur_node;
        case TYPE_OPERATOR:
            switch ((*cur_node) -> value){

                case OP_MUL:
                    if (((*cur_node) -> left -> node_type == TYPE_NUM && (*cur_node) -> left -> numdata == 0 ) ||
                    ((*cur_node) -> right -> node_type == TYPE_NUM && (*cur_node) -> right -> numdata == 0 )){
                        Change_by_Number(cur_node, 0);
                        cur_node = &(*cur_node) -> parent;
                        return Optimize(cur_node);
                    }
                    else if ((*cur_node) -> left -> node_type == TYPE_NUM && (*cur_node) -> left -> numdata == 1 ){
                        parent = (*cur_node) -> parent;
                        side = (*cur_node) -> right;
                        temp = Execute(side , parent , cur_node);
                        cur_node = &temp;
                        return Optimize(cur_node);
                    }
                    else if ((*cur_node) -> right -> node_type == TYPE_NUM && (*cur_node) -> right -> numdata == 1 ){
                        parent = (*cur_node) -> parent;
                        side = (*cur_node) -> left;
                        temp = Execute(side , parent , cur_node);
                        cur_node = &temp;
                        return Optimize(cur_node);

                    }
                    break;
                case OP_PLUS:
                    if ((*cur_node) -> left -> node_type == TYPE_NUM && (*cur_node) -> left -> numdata == 0 ){
                        temp = Execute((*cur_node) -> right, (*cur_node) -> parent, cur_node);
                        cur_node = &temp;
                        return Optimize(cur_node);
                    }
                    else if ((*cur_node) -> right -> node_type == TYPE_NUM && (*cur_node) -> right -> numdata == 0 ) {
                        parent = (*cur_node) -> parent;
                        side = (*cur_node) -> left;
                        temp = Execute(side , parent , cur_node);
                        cur_node = &temp;
                        return Optimize(cur_node);
                    }
                    break;
                case OP_POW:
                    if ((*cur_node) -> right -> node_type == TYPE_NUM && (*cur_node) -> right -> numdata == 0 ){
                        Change_by_Number(cur_node, 1);
                        return Optimize(cur_node);
                    }
                    break;
                default:
                    break;
            }
            temp = Optimize(&(*cur_node) -> right);

            if (temp == (*cur_node)->right) {
                temp = Optimize(&(*cur_node)->left);
                return temp == (*cur_node)-> left ? *cur_node : temp;
            } else
                return temp;

        default:
            printf("error");
            return nullptr;
    }
}

Node* Copy(Node* what){
    if(!what)
        return nullptr;
    Node* newNode = (Node*)calloc(sizeof(Node), 1);
    newNode -> node_type = what ->node_type;
    newNode -> left = Copy(what->left);
    newNode -> right = Copy(what->right);
    newNode ->  numdata = what-> numdata ;
    newNode ->  parent = what-> parent;
    newNode ->  value = what-> value;
    return newNode;
}

bool Find_var_in_tree(Node* cur_node, char* variable){
    if (!cur_node)
        return 0;
    if ( cur_node -> node_type == TYPE_VAR  && Var_array.var[cur_node -> value].id == *variable) {
        return 1;
    }
    if ( cur_node -> left || cur_node -> right ) {
        return Find_var_in_tree(cur_node -> left, variable) ? 1 : Find_var_in_tree(cur_node -> right, variable);
    }
    return 0;
}


#define MUL(left, right)    Create_new_Node(left, right, TYPE_OPERATOR, 0, OP_MUL  )
#define DIV(left, right)    Create_new_Node(left, right, TYPE_OPERATOR, 0, OP_DIV  )
#define POW(left, right)    Create_new_Node(left, right, TYPE_OPERATOR, 0, OP_POW  )
#define PLUS(left, right)   Create_new_Node(left, right, TYPE_OPERATOR, 0, OP_PLUS )
#define MINUS(left, right)  Create_new_Node(left, right, TYPE_OPERATOR, 0, OP_MINUS)
#define CREATE_EMPTY Create_new_Node(nullptr, nullptr, TYPE_NUM, 0, 0 )


Node* diff(Node* cur_node,  char* variable){

      switch (cur_node ->node_type){
          case TYPE_NUM:
              return  CREATE_EMPTY;
          case TYPE_VAR:
              if (Var_array.var[cur_node -> value].id == *variable) {
                  return Create_new_Node(nullptr, nullptr, TYPE_NUM, 1, 0 );
              }
              else
                  return CREATE_EMPTY;

          case TYPE_OPERATOR:
              switch (cur_node -> value){
                  case OP_MINUS:
                      return MINUS(diff(cur_node -> left, variable), diff(cur_node -> right, variable));
                  case OP_PLUS:
                      return PLUS(diff(cur_node -> left, variable), diff(cur_node -> right, variable));
                  case OP_MUL:
                      return PLUS(MUL(diff(cur_node -> left, variable), Copy(cur_node -> right)),
                                  MUL(Copy(cur_node -> left), diff(cur_node -> right, variable)));
                  case OP_DIV:
                      return DIV(MINUS(MUL(diff(cur_node -> left, variable), cur_node -> right),
                                       MUL(Copy(cur_node -> left), diff(cur_node->right, variable))),
                                 MUL(Copy(cur_node -> right), Copy(cur_node -> right)));
                  case OP_SIN:
                      return MUL(diff(cur_node -> left ? cur_node -> left : cur_node -> right, variable),
                              Create_new_Node(nullptr, Copy(cur_node -> left ? cur_node -> left : cur_node -> right), TYPE_OPERATOR, 0, OP_COS)) ;
                  case OP_COS:
                      return MUL(diff(cur_node -> left ? cur_node -> left : cur_node -> right, variable),
                                 MINUS(CREATE_EMPTY,
                                         Create_new_Node(nullptr, Copy(cur_node -> left ? cur_node -> left : cur_node -> right), TYPE_OPERATOR, 0, OP_SIN))) ;
                  case OP_POW:
                      return  MUL(POW(Copy(cur_node -> left), Copy(cur_node -> right)),
                                         PLUS(MUL(diff(Create_new_Node(Copy(cur_node -> left), nullptr, TYPE_OPERATOR, 0, OP_LOGE), variable),
                                                            Copy(cur_node -> right)),
                                                   MUL(Create_new_Node(Copy(cur_node -> left), nullptr, TYPE_OPERATOR, 0, OP_LOGE),
                                                            diff(cur_node -> right, variable)))
                                 );
                  case OP_LOGE:
                      return Find_var_in_tree(cur_node, variable) ? MUL(DIV(Create_new_Node(nullptr, nullptr, TYPE_NUM, 1, 0 ),
                                                                                 Copy(cur_node -> left ? cur_node -> left : cur_node -> right)),
                                                                     diff(cur_node -> left ? cur_node -> left : cur_node -> right, variable))
                                                                  : CREATE_EMPTY;
                  case OP_EXP:
                      return MUL(Copy(cur_node),diff(cur_node -> left ? cur_node -> left : cur_node -> right, variable));
                  default:
                      printf("Unexpected operand\n");
                      return nullptr;
              }
      }
    return nullptr;
}

int getFileLength (FILE* flin){
    fseek(flin, 0, SEEK_END);
    int length = ftell(flin);
    fseek(flin, 0 , SEEK_SET);
    return  length;
}

Node* Tree_Construct(FILE* flin) {

    int length_remaining = getFileLength(flin);
    Node* head_node = Create_Node_from_file(flin, nullptr, &length_remaining);
    if(!length_remaining){
        return head_node;
    } else {
        Deconstruct_Nodes(head_node);
        return nullptr;
    }

}

void* Deconstruct_Nodes(Node* cur_node){
    if(!cur_node){
        return nullptr;
    }
    if (cur_node -> parent){
        cur_node -> parent -> left == cur_node ? cur_node -> parent -> left = nullptr
                                               : cur_node -> parent -> right = nullptr;
    }
    Deconstruct_Nodes(cur_node->left);
    Deconstruct_Nodes(cur_node->right);
    free(cur_node);
    return nullptr;
}



int Skip_spaces(FILE* flin){
    int position = 0;
    fscanf(flin, "%*[ \n\t]%n", &position);
    return position;
}

bool Find_inFunctions(char* string){
    if (sscanf(string, " %[*+-/^]" , string ))
        return 1;
    if (strcmp("pow", string) == 0)
        return 1;
    for(int i = 0; i < FUNCTION_NUM; i++){
        if(strcmp(string, functions[i].name) == 0){
            return 1;
        }
    }
    return 0;
}

int Find_inVars(int id){
    for(int i =0; i < Var_array.size; i++){
        if( id == Var_array.var[i].id )
            return i;
    }
    return -1;
}



Node* Create_new_branch( FILE* flin, Node* cur_node, int* length_remaining ){
    Node* side = nullptr;

    *length_remaining -= Skip_spaces(flin);
    if (getc(flin) == '(') {
        fseek(flin, -1, SEEK_CUR);
        side = Create_Node_from_file(flin, cur_node, length_remaining);

    } else fseek(flin, -1, SEEK_CUR);
    return side;
}

Node* Create_Node_from_file(FILE* flin, Node* Parent, int* length_remaining){
    *length_remaining -= Skip_spaces(flin);
    if (*length_remaining <= 0 || fgetc(flin) == ')' ){
        fseek(flin, -1, SEEK_CUR);
        return nullptr;
    }
    fseek(flin, -1, SEEK_CUR);

    if (fgetc(flin) != '('){
        fseek(flin, -1, SEEK_CUR);
        printf("syntax error in char %ld", ftell(flin));
        return nullptr;
    }
    *length_remaining -= 1;

    Node* cur_node = (Node*)calloc(1, sizeof(Node));
    int position = 0;
    cur_node -> parent = Parent;

    cur_node -> left = Create_new_branch( flin, cur_node, length_remaining);


    *length_remaining -= Skip_spaces(flin);

    char fun[MAXLEN] = "";
    if (!fscanf(flin, "%[^()]%n", fun, &position)){
        fseek(flin, -1, SEEK_CUR);
        printf("syntax error in char %ld %c", ftell(flin), fgetc(flin));
    }

    if(position > MAXLEN){
        printf("Строка слишком большая! проверьте код");
        free(cur_node);
        return nullptr;
    }
    *length_remaining -= Skip_spaces(flin) + position;

    Set_Type(fun, cur_node);

    if (fgetc(flin) == ')'){
        *length_remaining -= 1;
        return cur_node;
    }
    fseek(flin, -1, SEEK_CUR);

    cur_node -> right = Create_new_branch(flin, cur_node, length_remaining);
    *length_remaining -= Skip_spaces(flin);

    if (fgetc(flin) == ')'){
        *length_remaining -= 1;
        return cur_node;
    }
    else printf("syntax error");
    fseek(flin, -1, SEEK_CUR);
    return cur_node;
}
#define COMP(what, fun) \
if( stricmp(#what, fun) == 0)  \
 return OP_##what


int OP(char* fun){
    switch (*fun) {
        case '+':
            return OP_PLUS;
        case '-':
            return OP_MINUS;
        case '*':
            return OP_MUL;
        case '/':
            return OP_DIV;
        case '^':
            return OP_POW;
        default:
            COMP(SIN, fun);
            COMP(COS, fun);
            COMP(POW, fun);
            COMP(TAN, fun);
            COMP(LOGE, fun);
            COMP(LOG10, fun);
            COMP(PLUS, fun);
            COMP(MINUS, fun);
            COMP(MUL, fun);
            COMP(DIV, fun);
            COMP(COT, fun);
            COMP(ASIN, fun);
            COMP(ACOS, fun);
            COMP(ATAN, fun);
            COMP(SINH, fun);
            COMP(COSH, fun);
            COMP(TANH, fun);
            COMP(EXP, fun);
            return -1;
    }

}

void Set_Type(char* fun, Node* cur_node){
    double data = strtod(fun, nullptr);
    if (errno == ERANGE || (data == 0 && *fun != '0')){
        if (!Find_inFunctions(fun)) {
            cur_node->node_type = TYPE_VAR;
            int key = Find_inVars(*fun);
            if(!(key+1)) {
                Var_array.var[Var_array.size].id = *fun;
                strcpy(Var_array.var[Var_array.size].name, fun);
                cur_node -> value = Var_array.size++;
            } else {
                cur_node -> value = key;
            }
        }
        else {
            cur_node -> node_type = TYPE_OPERATOR;
            cur_node -> value = OP(fun);
        }

    }
    else {
        cur_node ->node_type = TYPE_NUM;
        cur_node->numdata = data;
    }
}

void Print_tree_in_file(Node* cur_node, FILE* flout){
    if (!cur_node)
        return;
    fputc( '(', flout);
    Print_tree_in_file(cur_node->left, flout);
    Print_phrase(flout, cur_node);
    Print_tree_in_file(cur_node->right, flout);
    fputc( ')', flout);
}
